dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
### QPCR PLATE FRAMING & ADJUSTMENT MODEL ###
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
# Mac Directory
setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_11")
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
View(deriv)
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
calib_data = calib_df
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
View(calib_data)
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
data$test1 = as.numeric(as.character(data$test1))
data$allP = as.numeric(as.character(data$allP))
adj_val = c()
allP = c()
startq = c()
ratio =data$allP/data$test1
View(data)
# Append ratios to data set
data=cbind(data,ratio)
View(data)
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
View(calib_data)
adjusted_test1 <- test1 + adj_val
# Append adjusted test1 values to data set
data=cbind(data,adjusted_test1)
View(data)
# Reorder columns so test1 and adj test1 are adjacent
data=data[,c(1,2,5,3,4)]
View(data)
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
data$test1 = as.numeric(as.character(data$test1))
data$allP = as.numeric(as.character(data$allP))
adj_val = c()
allP = c()
startq = c()
# Calculate ratio values
ratio =data$allP/data$test1
# Append ratios to data set
data=cbind(data,ratio)
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
# Calculate adjusted test1 value
adjusted_test1 <- test1 + adj_val
# Append adjusted test1 values to data set
data=cbind(data,adjusted_test1)
View(data)
# Append adjusted test1 values to data set
data=cbind(data,adjusted_test1)
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
dev.off()
scatter.smooth(ratio, adj_val)
abline(ratio, adj_val)
compare_data = cbind(adj_val, ratio)
View(compare_data)
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
data$test1 = as.numeric(as.character(data$test1))
data$allP = as.numeric(as.character(data$allP))
adj_val = c()
allP = c()
startq = c()
# Calculate ratio values
ratio =data$allP/data$test1
# Append ratios to data set
data=cbind(data,ratio)
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
# Calculate adjusted test1 value
adjusted_test1 <- test1 + adj_val
# Append adjusted test1 values and adjustment value to data set
data=cbind(data,adjusted_test1)
View(data)
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
data$test1 = as.numeric(as.character(data$test1))
data$allP = as.numeric(as.character(data$allP))
adj_val = c()
allP = c()
startq = c()
# Calculate ratio values
ratio =data$allP/data$test1
# Append ratios to data set
data=cbind(data,ratio)
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
# Calculate adjusted test1 value
adjusted_test1 <- test1 + adj_val
# Append adjusted test1 values and adjustment value to data set
data=cbind(data,adjusted_test1,adj_val)
View(data)
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
dev.off()
scatter.smooth(ratio, adj_val)
abline(ratio, adj_val)
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
dev.off()
scatter(ratio, adj_val)
plot(ratio, adj_val)
plot(ratio, adj_val)
abline(ratio, adj_val)
plot(adj_model)
scatterplot(ratio, adj_val)
plot(ratio, adj_val)
abline(lm(adj_val~ratio)
)
abline(lm(adj_val~ratio))
plot(ratio, adj_val, main="Ratios vs. Adjustment Value")
abline(lm(adj_val~ratio), col="blue")
plot(ratio, adj_val, main="Ratios vs. Adjustment Value", col="blue")
abline(lm(adj_val~ratio), col="blue")
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
plot(adj_model)
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
# Plot adjustment model
par(mfrow = c(2,2))
plot(adj_model)
plot(adj_model)
dev.off()
# Plot ratios vs. adjustment values
plot(ratio, adj_val, main="Ratios vs. Adjustment Values", col="blue")
abline(lm(adj_val~ratio), col="blue")
abline(lm(adj_val~ratio), col="blue", xlab("Ratio"), ylab("Adjustment Value"))
abline(lm(adj_val~ratio), col="blue", xlab="Ratio", ylab="Adjustment Value")
# Plot ratios vs. adjustment values
plot(ratio, adj_val, main="Ratios vs. Adjustment Values", col="blue")
abline(lm(adj_val~ratio), col="blue", xlab="Ratio", ylab="Adjustment Value")
# Plot ratios vs. adjustment values
plot(ratio, adj_val, main="Ratios vs. Adjustment Values", col="blue", xlab="Ratio", ylab="Adjustment Value")
abline(lm(adj_val~ratio), col="blue")
abline(lm(adj_val~ratio), col="blue")
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
View(exp_data)
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = filter(freq, !freq$Freq==2)
countsne2 = filter(counts, !freq$Freq==2)
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = filter(counts, !counts$Freq==2)
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
write.csv(file="2018_11_SamplesToInvestigate", freq2)
View(countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = exp_data[-countsne2]
typeof(countsne2)
typeof(remove)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = exp_data[!(exp_data$sampleID == countsne2)]
View(exp_data)
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
View(exp_data)
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = filter(counts, !counts$Freq==2)
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = as.data.frame(exp_data[!(exp_data$sampleID == countsne2)])
View(exp_data)
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = exp_data[!(exp_data$sampleID == c(countsne2)]
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = exp_data[!(exp_data$sampleID == c(countsne2)]
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = exp_data[!(exp_data$sampleID == c(countsne2))]
View(exp_data)
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = filter(counts, !counts$Freq==2)
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
#remove = countsne2
exp_data = exp_data[!(exp_data$sampleID == c(countsne2))]
View(exp_data)
View(countsne2)
list(countsne2)
head(countsne2)
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = filter(counts, !counts$Freq==2)
# Write CSV file of samples with count not equal to 2 to send to Dr. S for investigation
### To work on --> add derivative values in to the CSV file
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Manually remove samples with only one reaction type (allP or test1)
remove = countsne2$Var1
exp_data = exp_data[!(exp_data$sampleID == remove)]
head(remove)
remove
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = filter(counts, !counts$Freq==2)
head(countsne2$Var1)
countne2$Var
countsne2$Var1
countsne2
countsne2 = filter(counts, !counts$Freq==2)
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
View(countsne2)
countsne2$Var1
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
View(counts)
countsne2 = filter(counts, !counts$Freq==2)
View(counts)
View(countsne2)
keep <- which(!names(exp_data$sampleID) %in% names(countsne2$Var1))
keep <- which(names(exp_data$sampleID) %in% names(countsne2$Var1))
typeof(keep)
keep <- which(names(countsne2$Var1) %in% names(exp_data$sampleID))
?which
remove=match(exp_data$sampleID, countsne2$Var1)
view(remove)
head(remove)
remove=match(exp_data$sampleID, countsne2$Var1)
View(remove)
length(counts)
length(countsne2)
length(countsne2$Var1)
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
remove=match(exp_data$sampleID, countsne2$Var1)
?detect
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
View(countsne2)
# Read in Expiremental Data
calib_df <- read.csv(file = "2018_6_1_Experimental_Data_Frame_with_Derivatives.csv", head=TRUE)
# Format starting quantity as numeric
calib_df <- calib_df[c(4,2,3,5,6)]
# Remove first extra labeling row --->> ADD THIS TO FRAMING CODE SO WONT MANUALLY
#exp_data <- exp_data[-1,]
# Sort data by sample ID
calib_df <- calib_df[order(calib_df$sampleID),]
write.csv(calib_df, file="2018_6_1_Calibrated_Data_Frame.csv")
#Create data frame for Calibrated values -- by detecting if a "g" is in sample ID, i.e. there is a known starting quantity
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Indicate if sample is 'Plus' or 'Minus'
calib_df['sampleID_Plus'] = grepl('plus', calib_df$sampleID)
View(calib_df)
# Remove 'Minus' values (include only gblock+ values)
minus = which(!calib_df$sampleID_Plus)
calib_df = calib_df[-minus,]
View(calib_df)
?detect
?grepl
exp_data['CountNotEq2'] = grepl(countsne2$Var1, exp_data$sampleID)
View(exp_data)
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
View(countsne2)
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
exp_data['CountNotEq2'] = grep(countsne2$Var1, exp_data$sampleID)
exp_data['CountNotEq2'] = grep(countsne2$Var1, exp_data$sampleID, value=TRUE)
exp_data['CountNotEq2'] = grep(countsne2$Var1, exp_data$sampleID,perl = TRUE)
View(exp_data)
?match
exp_data2 = exp_data[!exp_data$sampleID %in% countsne2$Var1]
exp_data2 = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
View(exp_data2)
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
# Send removed sampleID's to Dr. S, with additional plots of raw cycle values for each of these samples
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
exp_data['CountNotEq2'] = grep(countsne2$Var1, exp_data$sampleID, perl = TRUE)
View(exp_data)
exp_data = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
View(exp_data)
