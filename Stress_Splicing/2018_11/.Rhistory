r=(12,12,12,)
c
r=c(12,12,12,)
r=12,13,13
r=c(12,13,13)
e=c(13,14,14)
c=c(13,13,4)
rec
r*e*c
r*
e*
c*.
fesdf
mySum(input_1 = 1, 3)
input_1 <- 20
mySum <- function(input_1, input_2 = 10) {
output <- input_1 + input_2
return(output)
}
}
mySum(input_1 = 1, 3)
mySum(3)
mySum(input_2 = 3)
center <- function(data, desired) {
new_data <- (data - mean(data)) + desired
return(new_data)
}
z<-c(1,2,3,4,5,6,7,8,9,10)
center(z)
center(z,4)
mean(center(z,4))
z<-c(0,0,0,0)
center(z,3)
dat <- read.csv(file = "data/inflammation-01.csv", header = FALSE)
centered <- center(dat[, 4], 0)
head(centered)
install.packages("qtl2", repos="http://rqtl.org/qtl2cran")
z<-c(0,0,0)
z<-c(0,0,0,0)
print("Hello")
print("Bom dia")
source('~/stapleton_lab/Test2.R')
install.packages("qtl")
vqtl
install.packages("purrr")
install.packages("readr")
install.packages("dplyr")
print("Bom Dia meus amigos!")
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
library(qtl)
library(qtl)
library(qtl)
summary(hyper)
data("hyper")
summary(hyper)
nind(hyper)
nphe(hyper)
nchr(hyper)
totmar(hyper)
nmar(hyper)
plot(hyper)
data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
install.packages("readr")
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
dat <- read.cross(file = "./Manching_Practice_Data.csv")
summary(dat)
#vQTL with simulated data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
# setwd("/Users/mbyrd/StapletonLab/Stapleton_Lab/vQTL_Practice")
# Michael Stampede Path
# setwd ("/work/04908/mcb4548/stampede2/GitHub/Stapleton_Lab/vQTL_Practice")
dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
#vQTL with simulated data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
# setwd("/Users/mbyrd/StapletonLab/Stapleton_Lab/vQTL_Practice")
# Michael Stampede Path
# setwd ("/work/04908/mcb4548/stampede2/GitHub/Stapleton_Lab/vQTL_Practice")
dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
### Combining Genomes and Mo###
library(stringr)
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing")
setwd("/Users/andrewnorris/stapleton_lab/JCastillo/StapletonLab/StressSplicing")
dat = read.csv(file = "Plant_Height.csv", header = TRUE)
#Take out unneeded IBMB###, NA, B73 loci
dat = dat[-(907:938),-(4:5)]
#Create Categorical Variables for PH207*Mo### and Mo### by gene breed
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Outbred")
dat = cbind(dat, BreedType)
#Add in SNP info from CSV, beginning with column six
snp = read.csv(file = "IBM94markerset08seq.csv")
snp = snp[,-(1:5)]
#Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(dat$Genotype)*dim(snp)[1]), ncol = dim(snp)[1]))
#From
dat2 = sapply(str_sub(dat$Genotype,-3,-1), function(x){
column = which(str_sub(colnames(snp),-3,-1) == x)
vect = data.frame(as.character(snp[,column]))
return(vect)
})
View(dat2)
#From "Genotype" values,
dat2 = sapply(str_sub(dat$Genotype,-3,-1), function(x){
column = which(str_sub(colnames(snp),-3,-1) == x)
vect = data.frame(as.character(snp[,column]))
return(vect)
})
dat2 = as.data.frame(matrix(unlist(dat2), nrow = dim(dat)[1], byrow = TRUE))
View(dat2)
#Add matched Mo### values to data frame
dat2 = as.data.frame(matrix(unlist(dat2), nrow = dim(dat)[1], byrow = TRUE))
colnames(dat2) = colnames()
library(beepr)
beep()
dim(dat3);dim(snp)
#####Adding back in the Trait info#####
dat3 = cbind(dat2$Height,dat2[,1:3],dat3)
### Combining Genomes and Mo###
library(stringr)
setwd("/Users/andrewnorris/stapleton_lab/Stress_Splicing")
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing")
dat = read.csv(file = "Plant_Height.csv", header = TRUE)
#Take out unneeded IBMB###, NA, B73 loci
dat = dat[-(907:938),-(4:5)]
#Create Categorical Variables for PH207*Mo### and Mo### by gene breed
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Outbred")
dat = cbind(dat, BreedType)
#Add in SNP info from Marker data CSV, beginning with column six
snp = read.csv(file = "IBM94markerset08seq.csv")
snp = snp[,-(1:5)]
#Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(dat$Genotype)*dim(snp)[1]), ncol = dim(snp)[1]))
#From "Genotype" values, match Plant Height data and Marker data by detecting last three digits of Mo###'s
dat2 = sapply(str_sub(dat$Genotype,-3,-1), function(x){
column = which(str_sub(colnames(snp),-3,-1) == x)
vect = data.frame(as.character(snp[,column]))
return(vect)
})
#Add matched Mo### values to data frame
dat2 = as.data.frame(matrix(unlist(dat2), nrow = dim(dat)[1], byrow = TRUE))
View(dat2)
#####Adding marker location and chromosome#####
aux = matrix(snp$incre_new, nrow= 1)
#####Adding back in the Trait info#####
dat3 = cbind(dat2$Height,dat2[,1:3],dat3)
relevant = data.frame(matrix(rep(0,length(dat$sampleID)*dim(exp_data)[1]), ncol = dim(exp_data)[1]))
## If zero matrix is the way to go... #Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(data$sampleID)*dim(exp_data)[1]), ncol = dim(exp_data)[1]))
## If zero matrix is the way to go... #Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(data$sampleID)*dim(exp_data)[1]), ncol = dim(exp_data)[1]))
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
library(tidyr)
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Mac Directory
setwd("Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Read in Calibration Data
data <- read.csv(file = "2018_6_1_Calibrated_Data_Frame_with_Derivatives.csv")
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
# Mac Directory
setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_11")
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
#Remove extra labels row,
deriv = deriv[-1,]
#Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
#Remove extra labels row
deriv=deriv[-1,]
#Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
#Remove extra labels row
deriv=deriv[-1,]
write.csv(deriv, file="2018_11_qPCR_output_withHeaders.csv")
#Create new transposed data set
deriv2=read.csv(file="2018_11_qPCR_output_withHeaders.csv", header=TRUE)
#Remove unneeded labeling column
deriv2=deriv2[,-1]
#Indicate if sample is NTC (negative control)
deriv2['sampleID_NTC'] = grepl('NTC', deriv2$sampleID)
#Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv2$sampleID_NTC)
deriv2 = deriv2[-ntc,]
deriv2 = deriv2[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv2['sampleID_Minus'] = grepl('minus', deriv2$sampleID)
#Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv2$sampleID_Minus)
deriv2 = deriv2[-minus,]
deriv2 = deriv2[,-c(5)]
#Write CSV file
write.csv(deriv2, file="2018_11_qPCR_output_New.csv")
#Re-read in CSV values --> this allows for-loop to work properly
deriv2=read.csv(file="2018_11_qPCR_output_New.csv", header=TRUE)
#Remove labels column
deriv2=deriv2[,-1]
###CALIBRATED DATA FRAME###
#Create/Write data frame for Calibrated values
calib_df = deriv2 %>% filter(str_detect(sampleID, "g"))
#Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
write.csv(calib_df, file="2018_11_Calibrated_Data_Frame.csv")
#Create new transposed data set
calib_data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
#Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
#Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
write.csv(calib_data, file="2018_11_Calibrated_Data_Frame.csv")
View(calib_data)
###ADJUSTMENT MODEL###
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
adj_val = c()
allP = c()
startq = c()
ratio = data$allP/data$test1
ratio = data$allP/data$test1
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
# Using the adjustment model on the expiremental data
new = data.frame(ratio = exp_data$all_productsPrimers_Cp1/exp_data$test1_Cp1)
predict(adj_model, new , interval = "confidence")
###ADJUSTMENT MODEL###
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
adj_val = c()
allP = c()
startq = c()
ratio = data$allP/data$test1
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val
head(adjusted_test1)
adjusted_test1 <- test1 + adj_val
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
plot(adj_model)
plot(adj_model)
adj_model
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
# Using the adjustment model on the expiremental data
new = data.frame(ratio = exp_data$all_productsPrimers_Cp1/exp_data$test1_Cp1)
View(deriv2)
abline(adj_model)
scatter(adj_model)
plot(abline(adj_model))
plot(ratio,adj_val)
abline(ratio, adj_val)
abline()
abline(adj_model)
dev.off()
plot(ratio,adj_val)
abline(adj_model)
?predict
###EXPERIMENTAL DATA FRAME###
#Create/Write data frame for Calibrated values
exp_df = deriv2 %>% filter(str_detect(sampleID, "g")==FALSE)
#Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
View(exp_df)
#Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
View(exp_df)
exp_df = exp_df[-nrow(exp_df),]
View(exp_df)
write.csv(exp_df, file="2018_11_Experimental_Data_Frame.csv")
#Create new transposed data set
exp_data=read.csv(file="2018_11_Experimental_Data_Frame.csv", header=TRUE)
View(exp_data)
#Remove extra labeling column
exp_data = exp_data[,-1]
View(exp_data)
View(exp_data)
View(exp_data)
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
startq.exp = c()
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
#Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
View(exp_data)
#Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
#For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID
exp_data = cbind(sampleID.exp, test1.exp, allP.exp)
View(exp_data)
###EXPERIMENTAL DATA FRAME###
#Create/Write data frame for Calibrated values
exp_df = deriv2 %>% filter(str_detect(sampleID, "g")==FALSE)
#Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
#Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
write.csv(exp_df, file="2018_11_Experimental_Data_Frame.csv")
#Create new transposed data set
exp_data = read.csv(file="2018_11_Experimental_Data_Frame.csv", header=TRUE)
#Remove extra labeling column
exp_data = exp_data[,-1]
#Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
expdata2=exp_data
View(expdata2)
#Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
#For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID
exp_data = cbind(sampleID.exp, test1.exp, allP.exp)
View(exp_data)
### EXPERIMENTAL DATA FRAME ###
#Create/Write data frame for Calibrated values
exp_df = deriv2 %>% filter(str_detect(sampleID, "g")==FALSE)
#Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
#Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
write.csv(exp_df, file="2018_11_Experimental_Data_Frame.csv")
#Create new transposed data set
exp_data = read.csv(file="2018_11_Experimental_Data_Frame.csv", header=TRUE)
#Remove extra labeling column
exp_data = exp_data[,-1]
#Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
View(exp_data)
