#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
print(divide(group$k$a, group$k$b))
#print(k)
}
#print(divide(group$k$a, group$k$b))
print(k)
for (k in names){
#print(divide(group$k$a, group$k$b))
print(k)
}
print(divide(group$k$a, group$k$b))
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
group$names[1]
names[1]
group$(names[1])
#for each group in k, divide column a by column b
names = c(x, y, z)
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in names){
#print(divide(group$k$a, group$k$b))
print(k)
}
group$'x'
group$"x"
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
print(k)
group$k
group$print(k)
for (k in group){
print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in group){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in group){
#print(divide(group$k$a, group$k$b))
print(k)
}
k
k$a
k$a/k$b
divide(k$a, k$b)
k$a
k$a[1]
k$a[1]/k$b
k$a[2]/k$b
for (k in group){
print(divide(k$a, k$b))
print(k)
}
divide(k$a, k$b)
k$a
class(k$a)
for (k in group){
print(divide(c(k$a), c(k$b)))
#print(k)
}
divide(m$a, m$b)
class(m$a)
for (k in group){
A = k$a
B = k$b
print(divide(A, B))
#print(k)
}
for (k in group){
A = c(k$a)
B = c(k$b)
print(divide(A, B))
#print(k)
}
library(tidyverse)
m %>%
group_by(name) %>%
summarise(a.mean = mean(a))
m %>%
group_by(name) %>%
divide(a/b)
m %>%
group_by(name) %>%
divide(a,b)
gapply(m, name = "x", divide(k$a,k$b))
library(apply)
install.packages("apply")
library(apply)
install.packages("gapply")
library(gapply)
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
# split the matrix by each group
group = split(m, name)
one = group$x
two = group$y
three = group$z
divide(one$a, one$b)
divide(two$a, two$b)
group = split(m, name)
print(group)
one = group$x
two = group$y
three = group$z
divide(two$a, two$b)
two
two = as.data.frame(group$y)
two
divide(two$a, two$b)
A = group$y$a
B = group$y$b
divide(A, B)
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this fu
m
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
divide(m$a, m$b)
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(m$a, m$b)
# split the matrix by each group
group = split(m, name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
for (k in group){
print(divide(k$b, k$a))
#print(k)
}
print(divide(k$a, k$b))
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
library(vqtl)
?mean.qtl.dom
??mean.qtl.dom
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(a,b)
# split the matrix by each group
group = split(m, name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
print(finalg)
#stt grade calc
mid = .74
proj = c(14/15, 1,1,1,1)
final = 1
pres = 1
paper = 1
finalg = sum(mid*0.15, ave(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 100
pres = 100
paper = 100
finalg = sum(mid*0.15, ave(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
0.15+0.45+0.2+0.1+0.1
ave(proj)
mean(proj)
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = 75
paper = 75
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = 80
paper = 80
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = 90
paper = 90
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
14/15
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = (14/15)*100
paper = (14/15)*100
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
#stt grade calc
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 80
pres = (14/15)*100
paper = (14/15)*100
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
?matrix(
)
m = matrix(c(1,2,3,4,5,6,7,8,9), nrow =3 )
m\
m
flatten(m, across = "rows")
new = as.vector(m)
new
new = as.vector(as.data.frame(m)
)
new
newvector = as.vector(m)
new = as.vector(as.matrix.data.frame(m))
m = matrix(c(1,2,3,4,5,6,7,8,9), nrow =3 )
newvector = as.vector(m)
new = as.vector(as.matrix.data.frame(m))
new
?rep()
?sort()
grades
numLlvs <- 4
confusionMatrix(
factor(sample(rep(letters[1:numLlvs], 200), 50)),
factor(sample(rep(letters[1:numLlvs], 200), 50)))
install.packages("confusionMatrix")
library('caret')
numLlvs <- 4
confusionMatrix(
factor(sample(rep(letters[1:numLlvs], 200), 50)),
factor(sample(rep(letters[1:numLlvs], 200), 50)))
sample(rep(letters[1:numLlvs], 200), 50)
sample(rep(letters[1:numLlvs], 200), 50)
confusionMatrix(
factor(sample(rep(letters[1:numLlvs], 200), 50)),
factor(sample(rep(letters[1:numLlvs], 200), 50)))
library('dplyr')
library('ordinalNet')
sd.val = 0.2
sd.val.test = 0.1
eps = rnorm(21, 0, sd.val)
eps.test= rnorm(21, 0, sd.val.test)
stq =sort(rep(c(0.010, 0.050, 0.100, 0.500, 1.000, 0.005, 5.000), 3))
allp = (-2.5)*log(stq)+25+eps
test1 = -2.7*log(stq)+23+eps.test
plot( allp,log(stq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(15, 45), ylim = c(-6, 2))
points(test1,log(stq), col = 'blue')
abline(lm(log(stq)~allp), col = 'red')
abline(lm(log(stq)~test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
# create the data frame and include the z scores of test 1 and all p
data = as.data.frame(cbind(stq, allp, test1))
data$ztest1 = (data$test1 - mean(data$test1))/sd(data$test1)
data$zallP = (data$allp - mean(data$allp))/sd(data$allp)
## Model 1 ##
#define ordinal model starq~zallP+ztest1
covmat = as.matrix(data[, c(4,5)])
ordmod = ordinalNet(covmat, as.factor(data$stq))
summary(ordmod)
coef(ordmod, matrix=TRUE)
#kfold cv
set.seed(123)
ordfit = ordinalNetTune(covmat, as.factor(data$stq), family = "cumulative",
link = "logit", parallelTerms = TRUE, nonparallelTerms = TRUE,
warn = FALSE, printProgress = FALSE)
head(ordfit$loglik)
bestLambdaIndex = which.max(rowMeans(ordfit$loglik))
head(coef(ordfit$fit, matrix = TRUE, whichLambda = bestLambdaIndex))
sd.val = 0.2
sd.val.test = 0.1
eps = rnorm(21, 0, sd.val)
eps.test= rnorm(21, 0, sd.val.test)
stq =sort(rep(c(0.010, 0.050, 0.100, 0.500, 1.000, 0.005, 5.000), 3))
allp = (-2.5)*log(stq)+25+eps
test1 = -2.7*log(stq)+23+eps.test
#plot the two cp types against log starting quantity
plot( allp,log(stq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(15, 45), ylim = c(-6, 2))
points(test1,log(stq), col = 'blue')
abline(lm(log(stq)~allp), col = 'red')
abline(lm(log(stq)~test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
# create the data frame and include the z scores of test 1 and all p
data = as.data.frame(cbind(stq, allp, test1))
data$ztest1 = (data$test1 - mean(data$test1))/sd(data$test1)
data$zallP = (data$allp - mean(data$allp))/sd(data$allp)
#define ordinal model starq~zallP+ztest1
covmat = as.matrix(data[, c(4,5)])
ordmod = ordinalNet(covmat, as.factor(data$stq))
summary(ordmod)
coef(ordmod, matrix=TRUE)
#kfold cv
set.seed(123)
ordfit = ordinalNetTune(covmat, as.factor(data$stq), family = "cumulative",
link = "logit", parallelTerms = TRUE, nonparallelTerms = TRUE,
warn = FALSE, printProgress = FALSE)
head(ordfit$loglik)
bestLambdaIndex = which.max(rowMeans(ordfit$loglik))
head(coef(ordfit$fit, matrix = TRUE, whichLambda = bestLambdaIndex))
sd.val = 1
sd.val.test = 0.5
eps = rnorm(21, 0, sd.val)
eps.test= rnorm(21, 0, sd.val.test)
stq =sort(rep(c(0.010, 0.050, 0.100, 0.500, 1.000, 0.005, 5.000), 33))
allp = (-2.5)*log(stq)+25+eps
test1 = -2.7*log(stq)+23+eps.test
plot( allp,log(stq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(15, 45), ylim = c(-6, 2))
points(test1,log(stq), col = 'blue')
abline(lm(log(stq)~allp), col = 'red')
abline(lm(log(stq)~test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
# create the data frame and include the z scores of test 1 and all p
data = as.data.frame(cbind(stq, allp, test1))
data$ztest1 = (data$test1 - mean(data$test1))/sd(data$test1)
data$zallP = (data$allp - mean(data$allp))/sd(data$allp)
covmat = as.matrix(data[, c(4,5)])
ordmod = ordinalNet(covmat, as.factor(data$stq))
summary(ordmod)
coef(ordmod, matrix=TRUE)
#kfold cv
set.seed(123)
ordfit = ordinalNetTune(covmat, as.factor(data$stq), family = "cumulative",
link = "logit", parallelTerms = TRUE, nonparallelTerms = TRUE,
warn = FALSE, printProgress = FALSE)
head(ordfit$loglik)
bestLambdaIndex = which.max(rowMeans(ordfit$loglik))
head(coef(ordfit$fit, matrix = TRUE, whichLambda = bestLambdaIndex))
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/2018_11")
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/Heirarchical")
# MONTH 1 (2018_6 / JUNE) CALIBRATED DATA FRAME
calib_data_6 = read.csv("../2018_6/calib_2018_6.csv")[,-1]
calib_data_6$month ='june'
#calib_data_6
# MONTH 2 (2018_8 / AUGUST) CALIBRATED DATA FRAME
calib_data_8 = read.csv("../2018_8/calib_2018_8.csv")[,-1]
calib_data_8$month ='aug'
#calib_data_8
# MONTH 3 (2018_11 / NOVEMBER) CALIBRATED DATA FRAME
calib_data_11 = read.csv("../2018_11/calib_2018_11.csv")[,-1]
calib_data_11$month ='nov'
#calib_data_11
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
calib_data = calib_data[,-4]
# Drop rows containing NA
calib_data = na.omit(calib_data)
# Calculating test1 and allp zscores
calib_data$ztest1 = (calib_data$test1 - mean(calib_data$test1))/sd(calib_data$test1)
calib_data$zallP = (calib_data$allP - mean(calib_data$allP))/sd(calib_data$allP)
calib_subset = calib_data[,c(1, 4:7)]
dim(calib_data)
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
library(stringr)
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
calib_data = calib_data[,-4]
# Drop rows containing NA
calib_data = na.omit(calib_data)
# Calculating test1 and allp zscores
calib_data$ztest1 = (calib_data$test1 - mean(calib_data$test1))/sd(calib_data$test1)
calib_data$zallP = (calib_data$allP - mean(calib_data$allP))/sd(calib_data$allP)
calib_subset = calib_data[,c(1, 4:7)]
class(calib_subset$startq)
calib_subset$
)
plot(calib_subset$allP,log(calib_subset$startq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(15, 45), ylim = c(-6, 2))
points(calib_subset$test1,log(calib_subset$startq), col = 'blue')
abline(lm(log(calib_subset$startq)~calib_subset$allP), col = 'red')
abline(lm(log(calib_subset$startq)~calib_subset$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
#graphing log starting quantity to cp values
plot(calib_subset$allP,log(calib_subset$startq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(15, 45), ylim = c(-6, 2))
View(calib_subset)
plot(calib_data$allP,log(calib_data$startq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(15, 45), ylim = c(-6, 2))
points(calib_data$test1,log(calib_data$startq), col = 'blue')
abline(lm(log(calib_data$startq)~calib_data$allP), col = 'red')
abline(lm(log(calib_data$startq)~calib_data$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
plot(calib_data$allP,log(calib_data$startq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(0, 25), ylim = c(-6, 0))
points(calib_data$test1,log(calib_data$startq), col = 'blue')
abline(lm(log(calib_data$startq)~calib_data$allP), col = 'red')
abline(lm(log(calib_data$startq)~calib_data$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
plot(calib_data$allP,log(calib_data$startq), col = 'red', main = "Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data$test1,log(calib_data$startq), col = 'blue')
abline(lm(log(calib_data$startq)~calib_data$allP), col = 'red')
abline(lm(log(calib_data$startq)~calib_data$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
plot(calib_data_6$allP,log(calib_data_6$startq), col = 'red', main = "June Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_6$test1,log(calib_data_6$startq), col = 'blue')
abline(lm(log(calib_data_6$startq)~calib_data_6$allP), col = 'red')
abline(lm(log(calib_data_6$startq)~calib_data_6$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
plot(calib_data_8$allP,log(calib_data_8$startq), col = 'red', main = "August Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_8$test1,log(calib_data_8$startq), col = 'blue')
abline(lm(log(calib_data_8$startq)~calib_data_8$allP), col = 'red')
abline(lm(log(calib_data_8$startq)~calib_data_8$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
lot(calib_data_11$allP,log(calib_data_11$startq), col = 'red', main = "November Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_11$test1,log(calib_data_11$startq), col = 'blue')
abline(lm(log(calib_data_11$startq)~calib_data_11$allP), col = 'red')
abline(lm(log(calib_data_11$startq)~calib_data_11$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
plot(calib_data_11$allP,log(calib_data_11$startq), col = 'red', main = "November Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_11$test1,log(calib_data_11$startq), col = 'blue')
abline(lm(log(calib_data_11$startq)~calib_data_11$allP), col = 'red')
abline(lm(log(calib_data_11$startq)~calib_data_11$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
plot(calib_data_8$allP,log(calib_data_8$startq), col = 'red', main = "August Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_8$test1,log(calib_data_8$startq), col = 'blue')
abline(lm(log(calib_data_8$startq)~calib_data_8$allP), col = 'red')
abline(lm(log(calib_data_8$startq)~calib_data_8$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
#graphing log starting quantity to cp values
plot(calib_data$allP,log(calib_data$startq), col = 'red', main = "Hierarchical Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data$test1,log(calib_data$startq), col = 'blue')
abline(lm(log(calib_data$startq)~calib_data$allP), col = 'red')
abline(lm(log(calib_data$startq)~calib_data$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
