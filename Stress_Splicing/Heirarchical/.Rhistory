what[-name]
what[-1,]
#for each group in k, divide column a by column b
for (k in group){
k = k[.-(name)]
#print(divide(k$a, k$b))
print(k)
}
what[,-name]
what[,-1]
k = k[.-1]
k = k[,-1]
#for each group in k, divide column a by column b
for (k in group){
k = k[,-1]
#print(divide(k$a, k$b))
print(k)
}
#for each group in k, divide column a by column b
for (k in group){
k = k[,-1]
print(divide(k$a, k$b))
#print(k)
}
group$1
#for each group in k, divide column a by column b
for (k in group){
print(divide(group$k$a, group$k$b))
#print(k)
}
group$y$a
group$x$a
class(group$x$a)
class(group$y$a)
k = 1
print(divide(k$a, k$b))
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
print(divide(group$k$a, group$k$b))
#print(k)
}
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
print(divide(group$k$a, group$k$b))
#print(k)
}
#print(divide(group$k$a, group$k$b))
print(k)
for (k in names){
#print(divide(group$k$a, group$k$b))
print(k)
}
print(divide(group$k$a, group$k$b))
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
group$names[1]
names[1]
group$(names[1])
#for each group in k, divide column a by column b
names = c(x, y, z)
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in names){
#print(divide(group$k$a, group$k$b))
print(k)
}
group$'x'
group$"x"
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
print(k)
group$k
group$print(k)
for (k in group){
print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in group){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in group){
#print(divide(group$k$a, group$k$b))
print(k)
}
k
k$a
k$a/k$b
divide(k$a, k$b)
k$a
k$a[1]
k$a[1]/k$b
k$a[2]/k$b
for (k in group){
print(divide(k$a, k$b))
print(k)
}
divide(k$a, k$b)
k$a
class(k$a)
for (k in group){
print(divide(c(k$a), c(k$b)))
#print(k)
}
divide(m$a, m$b)
class(m$a)
for (k in group){
A = k$a
B = k$b
print(divide(A, B))
#print(k)
}
for (k in group){
A = c(k$a)
B = c(k$b)
print(divide(A, B))
#print(k)
}
library(tidyverse)
m %>%
group_by(name) %>%
summarise(a.mean = mean(a))
m %>%
group_by(name) %>%
divide(a/b)
m %>%
group_by(name) %>%
divide(a,b)
gapply(m, name = "x", divide(k$a,k$b))
library(apply)
install.packages("apply")
library(apply)
install.packages("gapply")
library(gapply)
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
# split the matrix by each group
group = split(m, name)
one = group$x
two = group$y
three = group$z
divide(one$a, one$b)
divide(two$a, two$b)
group = split(m, name)
print(group)
one = group$x
two = group$y
three = group$z
divide(two$a, two$b)
two
two = as.data.frame(group$y)
two
divide(two$a, two$b)
A = group$y$a
B = group$y$b
divide(A, B)
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this fu
m
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
divide(m$a, m$b)
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(m$a, m$b)
# split the matrix by each group
group = split(m, name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
for (k in group){
print(divide(k$b, k$a))
#print(k)
}
print(divide(k$a, k$b))
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
library(vqtl)
?mean.qtl.dom
??mean.qtl.dom
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(a,b)
# split the matrix by each group
group = split(m, name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
print(finalg)
#stt grade calc
mid = .74
proj = c(14/15, 1,1,1,1)
final = 1
pres = 1
paper = 1
finalg = sum(mid*0.15, ave(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 100
pres = 100
paper = 100
finalg = sum(mid*0.15, ave(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
0.15+0.45+0.2+0.1+0.1
ave(proj)
mean(proj)
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = 75
paper = 75
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = 80
paper = 80
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = 90
paper = 90
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
14/15
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 75
pres = (14/15)*100
paper = (14/15)*100
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
#stt grade calc
mid = 74
proj = c((14/15)*100, 100,100,100,100)
final = 80
pres = (14/15)*100
paper = (14/15)*100
finalg = sum(mid*0.15, mean(proj)*.45, final*.2, pres*.1, paper*.1)
print(finalg)
?matrix(
)
m = matrix(c(1,2,3,4,5,6,7,8,9), nrow =3 )
m\
m
flatten(m, across = "rows")
new = as.vector(m)
new
new = as.vector(as.data.frame(m)
)
new
newvector = as.vector(m)
new = as.vector(as.matrix.data.frame(m))
m = matrix(c(1,2,3,4,5,6,7,8,9), nrow =3 )
newvector = as.vector(m)
new = as.vector(as.matrix.data.frame(m))
new
?rep()
?sort()
grades
numLlvs <- 4
confusionMatrix(
factor(sample(rep(letters[1:numLlvs], 200), 50)),
factor(sample(rep(letters[1:numLlvs], 200), 50)))
install.packages("confusionMatrix")
library('caret')
numLlvs <- 4
confusionMatrix(
factor(sample(rep(letters[1:numLlvs], 200), 50)),
factor(sample(rep(letters[1:numLlvs], 200), 50)))
sample(rep(letters[1:numLlvs], 200), 50)
sample(rep(letters[1:numLlvs], 200), 50)
confusionMatrix(
factor(sample(rep(letters[1:numLlvs], 200), 50)),
factor(sample(rep(letters[1:numLlvs], 200), 50)))
library(ordinalNet)
library(ordinalgmifs) # contains hccmethyl data
library("Biobase")
data(hccmethyl)
data(hccmethyl, package = 'ordinalgmifs')
install.packages(c("cluster.datasets"), dependencies = TRUE)
data(hccmethyl, package = 'ordinalgmifs')
data.frame (hccframe)
ExpressionSet (hccmethyl)
data("hccframe")
data("hccmethyl")
y <- pData(hccframe)$group
View(hccframe)
?pData()
?pData
y <- Data(hccframe)$group
y <- data(hccframe)$group
dat = data("hccframe")
y <- dat$group
class(dat)
dat = as.dataframe(data("hccframe"))
dat = as.data.frame(data("hccframe"))
y <- dat$group
names(dat)
library(stringr)
library(dplyr)
library(pracma)
library(MASS)
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/Heirarchical")
calib_data_6 = read.csv("../2018_6/calib_2018_6.csv")[,-1]
calib_data_6$month ='june'
#>>>>>>> 5f33e18e3fce60a5c0d91821babf3d5b9f6982a3
calib_data_6
# MONTH 2 (2018_8 / AUGUST) CALIBRATED DATA FRAME
calib_data_8 = read.csv("../2018_8/calib_2018_8.csv")[,-1]
calib_data_8$month ='aug'
calib_data_8
# MONTH 3 (2018_11 / NOVEMBER) CALIBRATED DATA FRAME
calib_data_11 = read.csv("../2018_11/calib_2018_11.csv")[,-1]
calib_data_11$month ='nov'
calib_data_11
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
calib_data = calib_data[,-4]
# Drop rows containing NA
calib_data = drop_na(calib_data)
# Calculating test1 and allp zscores
calib_data$ztest1 = (calib_data$test1 - mean(calib_data$test1))/sd(calib_data$test1)
calib_data$zallP = (calib_data$allP - mean(calib_data$allP))/sd(calib_data$allP)
calib_subset = calib_data[,c(1, 4:7)]
# Ordinal Logistic Regression Model
model = polr(as.factor(calib_subset$startq) ~ ., data=calib_subset, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
# OLRM - SQ ~ Test1
model = polr(as.factor(calib_subset$startq) ~ calib_subset$ztest1, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
# # Bind test1 and allProd cpD1 values by starting quantity
# calib_data = as.data.frame(cbind(startq, test1, allP))
# # Format starting quantity values as decimals, not scientific notation
# calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
# calib_data$startq=as.factor(calib_data$startq)
# # Append ratios to data set
# calib_data_6 =calib_data
# # Create month indicator column
# calib_data_6$month = strrep('june', length(calib_data_6))
# =======
calib_data_6 = read.csv("../2018_6/calib_2018_6.csv")[,-1]
calib_data_6$month ='june'
#>>>>>>> 5f33e18e3fce60a5c0d91821babf3d5b9f6982a3
calib_data_6
# MONTH 2 (2018_8 / AUGUST) CALIBRATED DATA FRAME
calib_data_8 = read.csv("../2018_8/calib_2018_8.csv")[,-1]
calib_data_8$month ='aug'
calib_data_8
# MONTH 3 (2018_11 / NOVEMBER) CALIBRATED DATA FRAME
calib_data_11 = read.csv("../2018_11/calib_2018_11.csv")[,-1]
calib_data_11$month ='nov'
calib_data_11
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
calib_data = calib_data[,-4]
# Drop rows containing NA
calib_data = drop_na(calib_data)
# Calculating test1 and allp zscores
calib_data$ztest1 = (calib_data$test1 - mean(calib_data$test1))/sd(calib_data$test1)
calib_data$zallP = (calib_data$allP - mean(calib_data$allP))/sd(calib_data$allP)
calib_subset = calib_data[,c(1, 4:7)]
# Drop rows containing NA
calib_data = na.omit(calib_data)
# Calculating test1 and allp zscores
calib_data$ztest1 = (calib_data$test1 - mean(calib_data$test1))/sd(calib_data$test1)
calib_data$zallP = (calib_data$allP - mean(calib_data$allP))/sd(calib_data$allP)
calib_subset = calib_data[,c(1, 4:7)]
# Ordinal Logistic Regression Model
model = polr(as.factor(calib_subset$startq) ~ ., data=calib_subset, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model)))
# Ordinal Logistic Regression Model
model = polr(as.factor(calib_subset$startq) ~ ., data=calib_subset, Hess = TRUE)
View(calib_subset)
calib_subset = calib_data[,c(1, 4:7)]
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
calib_data = calib_data[,-4]
# Drop rows containing NA
calib_data = na.omit(calib_data)
# Calculating test1 and allp zscores
calib_data$ztest1 = (calib_data$test1 - mean(calib_data$test1))/sd(calib_data$test1)
calib_data$zallP = (calib_data$allP - mean(calib_data$allP))/sd(calib_data$allP)
calib_subset = calib_data[,c(1, 4:7)]
# Ordinal Logistic Regression Model
model = polr(as.factor(calib_subset$startq) ~ ., data=calib_subset, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
# OLRM - SQ ~ Test1
model1 = polr(as.factor(calib_subset$startq) ~ calib_subset$ztest1, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model1)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
# OLRM - SQ ~ Test1
model1 = polr(as.factor(calib_subset$startq) ~ ztest1 + jun + aug, data = calib_subset, Hess = TRUE)
# OLRM - SQ ~ Test1
model1 = polr(as.factor(calib_subset$startq) ~ ztest1 + june + aug, data = calib_subset, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model1)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
# OLRM - SQ ~ allP
model2 = polr(as.factor(calib_subset$startq) ~ zallP + june + aug, data = calib_subset, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model2)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
model1 = polr(as.factor(calib_subset$startq) ~ june + aug + ztest1, data = calib_subset, Hess = TRUE)
#(summary(model))
(ctable <- coef(summary(model1)))
## calculate and store p values
p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
options(scipen=999)
## combined table
(ctable <- cbind(ctable, "p value" = p))
