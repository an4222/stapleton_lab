# Michael Stampede Path
# setwd ("/work/04908/mcb4548/stampede2/GitHub/Stapleton_Lab/vQTL_Practice")
dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
#vQTL with simulated data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
# setwd("/Users/mbyrd/StapletonLab/Stapleton_Lab/vQTL_Practice")
# Michael Stampede Path
# setwd ("/work/04908/mcb4548/stampede2/GitHub/Stapleton_Lab/vQTL_Practice")
dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
### QPCR PLATE FRAMING & ADJUSTMENT MODEL ###
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
# Mac Directory
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_11")
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_(MONTH)")
# PC Directory
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "(YEAR_MONTH_PLATE_qPCR_output.csv", header=FALSE)
##########################################################
################### Initial Data Framing #################
##########################################################
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
############################
## Removing NTC and Minus ##
############################
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
### COMPLETED INITIAL DATA FRAMING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
#calib_data = calib_df    Do we need this?
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
#calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
### COMPLETED CALIBRATED DATA FRAME ###
##########################################################
##### Ordinal Logicistic Regression Calibrated Data ######
##########################################################
require(MASS)
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
library(MASS)
library(glm.predict)
library(compare)
# Mac Directory
setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_8")
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_(MONTH)")
# PC Directory
#setwd(~/Desktop/GIThub/StapletonLab/StressSplicing/qPCR/)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2, deriv.3)
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
##########################################################
################### Initial Data Framing #################
##########################################################
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
# IF "minus" RETURNS EMPTY VALUES, COMMENT OUT COMMAND BELOW
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
# Remove two extra label rows from center of data frame
deriv['label.row'] = grepl('cpD1', deriv$cpD1)
extra = which(deriv$label.row)
deriv = deriv[-extra,]
deriv = deriv[,-5]
deriv$cpD1 = as.numeric(as.character(deriv$cpD1))
##########################################################
############ Removing Ununsual Observations ##############
##########################################################
# Remove unusual observations from initial data frame (CT value less than 10)
unusual_obs_2018_8 = deriv %>% filter(deriv$cpD1 < 10)
deriv = deriv %>% filter(deriv$cpD1 >= 10)
### WORK ON: Appending raw plate cycle vals to unusual obs d.f.
View(unusual_obs_2018_8)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
deriv = deriv_complete
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
# IF "minus" RETURNS EMPTY VALUES, COMMENT OUT COMMAND BELOW
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
# Remove two extra label rows from center of data frame
deriv['label.row'] = grepl('cpD1', deriv$cpD1)
extra = which(deriv$label.row)
deriv = deriv[-extra,]
deriv = deriv[,-5]
deriv$cpD1 = as.numeric(as.character(deriv$cpD1))
View(deriv)
# Remove unusual observations from initial data frame (CT value less than 10)
unusual_obs_2018_8 = deriv %>% filter(deriv$cpD1 < 10)
View(unusual_obs_2018_8)
View(deriv_complete)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
deriv = deriv_complete
View(deriv_complete)
View(deriv)
# Remove extra labels row and column
deriv = deriv[,-1]
View(deriv)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
deriv = deriv_complete
# Remove extra column
deriv = deriv[,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
# IF "minus" RETURNS EMPTY VALUES, COMMENT OUT COMMAND BELOW
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
# Remove two extra label rows from center of data frame
deriv['label.row'] = grepl('cpD1', deriv$cpD1)
extra = which(deriv$label.row)
deriv = deriv[-extra,]
deriv = deriv[,-5]
deriv$cpD1 = as.numeric(as.character(deriv$cpD1))
View(deriv)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
deriv = deriv_complete
# Remove extra column
deriv = deriv[,-1]
View(deriv)
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
View(deriv)
# Rename columns
colnames(deriv)=c("plate_ID", "reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
View(deriv)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
deriv = deriv_complete
# Remove extra column
deriv = deriv[,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("plateID", "reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
View(deriv)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
View(deriv)
deriv = deriv[,-c(6,7)]
View(deriv)
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
# IF "minus" RETURNS EMPTY VALUES, COMMENT OUT COMMAND BELOW
deriv = deriv[-minus,]
View(deriv)
deriv = deriv[,-6]
View(deriv)
# Remove two extra label rows from center of data frame
deriv['label.row'] = grepl('cpD1', deriv$cpD1)
extra = which(deriv$label.row)
deriv = deriv[-extra,]
View(deriv)
deriv = deriv[,-6]
deriv$cpD1 = as.numeric(as.character(deriv$cpD1))
View(deriv)
# Remove unusual observations from initial data frame (CT value less than 10)
unusual_obs_2018_8 = deriv %>% filter(deriv$cpD1 < 10)
View(unusual_obs_2018_8)
View(deriv)
deriv = deriv %>% filter(deriv$cpD1 >= 10)
View(deriv)
View(unusual_obs_2018_8)
?match
cycle = as.data.frame(cbind(cycle1, cycle2, cycle3))
### WORK ON: Appending raw plate cycle vals to unusual obs d.f.
# Read in raw cycle data
cycle1 = read.csv(file = "2018_8_1_plate.csv", header = FALSE)
cycle2 = read.csv(file = "2018_8_2_plate.csv", header = FALSE)
cycle3 = read.csv(file = "2018_8_3_plate.csv", header = FALSE)
cycle = as.data.frame(cbind(cycle1, cycle2, cycle3))
View(cycle)
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
library(MASS)
library(glm.predict)
library(compare)
# Mac Directory
setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_8")
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_(MONTH)")
# PC Directory
#setwd(~/Desktop/GIThub/StapletonLab/StressSplicing/qPCR/)
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_08_02_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv.3=read.csv(file = "2018_08_03_plate_qPCR_output_2019_05_19.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "2018_8_1_plate_qPCR_output.csv", header=FALSE)
##########################################################
################### Initial Data Framing #################
##########################################################
deriv = deriv_complete
# Remove extra column
deriv = deriv[,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("plateID", "reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(6,7)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
# IF "minus" RETURNS EMPTY VALUES, COMMENT OUT COMMAND BELOW
deriv = deriv[-minus,]
deriv = deriv[,-6]
# Remove two extra label rows from center of data frame
deriv['label.row'] = grepl('cpD1', deriv$cpD1)
extra = which(deriv$label.row)
deriv = deriv[-extra,]
deriv = deriv[,-6]
deriv$cpD1 = as.numeric(as.character(deriv$cpD1))
### COMPLETED INITIAL DATA FRAMING ###
##########################################################
############ Removing Ununsual Observations ##############
##########################################################
# Remove unusual observations from initial data frame (CT value less than 10)
unusual_obs_2018_8 = deriv %>% filter(deriv$cpD1 < 10)
deriv = deriv %>% filter(deriv$cpD1 >= 10)
# ### WORK ON: Appending raw plate cycle vals to unusual obs d.f.
# # Read in raw cycle data
# cycle1 = read.csv(file = "2018_8_1_plate.csv", header = FALSE)
# cycle2 = read.csv(file = "2018_8_2_plate.csv", header = FALSE)
# cycle3 = read.csv(file = "2018_8_3_plate.csv", header = FALSE)
# cycle = as.data.frame(cbind(cycle1, cycle2, cycle3))
# unusual_obs_2018_8 = match()
# ### COMPLETED UNUSUAL OBSERVATIONS REMOVAL/REPORTING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
# Create/Write data frame for Calibrated values
calib_data = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_data = calib_data[order(calib_data$starting_quantity),]
calib_data$starting_quantity = as.numeric(as.character(calib_data$starting_quantity))
calib_data$cpD1 = as.numeric(as.character(calib_data$cpD1))
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
calib_data$startq = as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq = as.factor(calib_data$startq)
# Calculate ratio of allP/test1 --> PAIRWISE RATIOS -- INPUT FOR OLR MODEL
ratio = calib_data$allP/calib_data$test1
# Append ratios to data set
calib_data = cbind(calib_data, ratio)
### COMPLETED CALIBRATED DATA FRAME ###
##########################################################
############### Experimental Data Framing ################
##########################################################
# Create/Write data frame for Experimental values
exp_data = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_data = exp_data[order(exp_data$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_data = exp_data[-1,]
exp_data = exp_data[-nrow(exp_data),]
exp_data$cpD1 = as.numeric(as.character(exp_data$cpD1))
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
### Finding invalid observations ###
# Find invalid observations - Find counts of each unique sampleID; remove ones with count not equal to 2 from data frame
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
countsne2$Var1 = as.numeric(as.character(countsne2$Var1))
exp_data = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID, convert to data frame
exp_data = as.data.frame(cbind(sampleID.exp, test1.exp, allP.exp))
exp_data$test1.exp = as.numeric(as.character(exp_data$test1.exp))
exp_data$allP.exp = as.numeric(as.character(exp_data$allP.exp))
# Calculate ratios for experimental data
ratio.exp = exp_data$allP.exp/exp_data$test1.exp
# Append ratios to data set
exp_data = cbind(exp_data, ratio.exp)
### COMPLETED EXPERIMENTAL DATA FRAME ###
##########################################################
############### Combination Ratios for qPCR ##############
##########################################################
startquan = as.character(calib_data$startq)
allprod = calib_data$allP
t1 = calib_data$test1
dat = data.frame(cbind(startquan,allprod,t1), stringsAsFactors = FALSE)
dat$allprod = as.numeric(dat$allprod)
dat$t1 = as.numeric(dat$t1)
#Create divide funtion - every element in column 1 divided by every element in column 2
divide <- function(col1, col2){
ratio = NULL;
for (i in col1){
ratio = c(ratio,i/col2)
}
return(ratio)
}
#Subset data by starting quantity
group = split.data.frame(dat, dat$startquan)
# Calculate combination ratios at each starting quantity
combratio = NULL;
for (k in group){
combratio = c(combratio, divide(k$allprod, k$t1))
}
# Create data frame with unique ratios at each starting quantity
startqvalues = rep(unique(startquan), rep(9,9))
newratios.calib = data.frame(cbind(startqvalues, combratio), stringsAsFactors = FALSE)
newratios.calib$combratio = as.numeric(newratios.calib$combratio)
newratios.calib$startqvalues = as.numeric(newratios.calib$startqvalues)
### COMPLETED COMBINATION RATIOS ###
